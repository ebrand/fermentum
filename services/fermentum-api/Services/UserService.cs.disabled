using Fermentum.Auth.Data;
using Fermentum.Auth.Models;
using Fermentum.Auth.Models.DTOs;
using Microsoft.EntityFrameworkCore;
using System.Security.Cryptography;

namespace Fermentum.Auth.Services;

public class UserService : IUserService
{
    private readonly AuthDbContext _context;
    private readonly IAuthService _authService;
    private readonly ILogger<UserService> _logger;

    public UserService(AuthDbContext context, IAuthService authService, ILogger<UserService> logger)
    {
        _context = context;
        _authService = authService;
        _logger = logger;
    }

    public async Task<UserInfo?> GetUserInfoAsync(Guid userId)
    {
        var user = await _context.Users
            .FirstOrDefaultAsync(u => u.Id == userId && u.IsActive);

        if (user == null)
            return null;

        return new UserInfo
        {
            Id = user.Id,
            Email = user.Email,
            FirstName = user.FirstName,
            LastName = user.LastName,
            DisplayName = user.DisplayName,
            AvatarUrl = user.AvatarUrl,
            Phone = user.Phone,
            Address = user.Address,
            City = user.City,
            State = user.State,
            ZipCode = user.ZipCode,
            EmailVerified = user.EmailVerified,
            IsSystemAdmin = user.IsSystemAdmin,
            LastLoginAt = user.LastLoginAt
        };
    }

    public async Task<UserInfo> UpdateUserAsync(Guid userId, UpdateUserRequest request)
    {
        var user = await _context.Users
            .FirstOrDefaultAsync(u => u.Id == userId && u.IsActive);

        if (user == null)
            throw new ArgumentException("User not found");

        // Update user properties (only update if value is provided)
        if (!string.IsNullOrEmpty(request.FirstName))
            user.FirstName = request.FirstName;

        if (!string.IsNullOrEmpty(request.LastName))
            user.LastName = request.LastName;

        if (!string.IsNullOrEmpty(request.DisplayName))
            user.DisplayName = request.DisplayName;
        else if (!string.IsNullOrEmpty(request.FirstName) || !string.IsNullOrEmpty(request.LastName))
        {
            // Auto-generate display name from first/last name if not provided
            var firstName = request.FirstName ?? user.FirstName ?? "";
            var lastName = request.LastName ?? user.LastName ?? "";
            user.DisplayName = $"{firstName} {lastName}".Trim();
        }

        if (!string.IsNullOrEmpty(request.Phone))
            user.Phone = request.Phone;

        // Update address fields
        if (!string.IsNullOrEmpty(request.Address))
            user.Address = request.Address;

        if (!string.IsNullOrEmpty(request.City))
            user.City = request.City;

        if (!string.IsNullOrEmpty(request.State))
            user.State = request.State;

        if (!string.IsNullOrEmpty(request.ZipCode))
            user.ZipCode = request.ZipCode;

        user.UpdatedAt = DateTime.UtcNow;

        await _context.SaveChangesAsync();

        return new UserInfo
        {
            Id = user.Id,
            Email = user.Email,
            FirstName = user.FirstName,
            LastName = user.LastName,
            DisplayName = user.DisplayName,
            AvatarUrl = user.AvatarUrl,
            Phone = user.Phone,
            Address = user.Address,
            City = user.City,
            State = user.State,
            ZipCode = user.ZipCode,
            EmailVerified = user.EmailVerified,
            IsSystemAdmin = user.IsSystemAdmin,
            LastLoginAt = user.LastLoginAt
        };
    }

    public async Task<List<TenantUserInfo>> GetTenantUsersAsync(Guid tenantId)
    {
        var query = from tu in _context.TenantUsers
                   join u in _context.Users on tu.UserId equals u.Id
                   where tu.TenantId == tenantId && tu.Status == "active" && u.IsActive
                   orderby tu.CreatedAt
                   select new TenantUserInfo
                   {
                       UserId = u.Id,
                       Email = u.Email,
                       FirstName = u.FirstName,
                       LastName = u.LastName,
                       Role = tu.Role,
                       Status = tu.Status,
                       JoinedAt = tu.JoinedAt ?? tu.CreatedAt
                   };

        return await query.ToListAsync();
    }

    public async Task<ApiResponse> InviteUserAsync(Guid tenantId, InviteUserRequest request, Guid invitedBy)
    {
        try
        {
            // Check if user is already a member of the tenant
            var existingUser = await _authService.GetUserByEmailAsync(request.Email);
            if (existingUser != null)
            {
                var existingMembership = await _context.TenantUsers
                    .FirstOrDefaultAsync(tu => tu.TenantId == tenantId && tu.UserId == existingUser.Id);

                if (existingMembership != null)
                {
                    return new ApiResponse
                    {
                        Success = false,
                        Message = "User is already a member of this tenant"
                    };
                }
            }

            // Check for existing pending invitation
            var existingInvitation = await _context.Invitations
                .FirstOrDefaultAsync(i => i.TenantId == tenantId && i.Email == request.Email && i.Status == "pending");

            if (existingInvitation != null)
            {
                return new ApiResponse
                {
                    Success = false,
                    Message = "An invitation has already been sent to this email address"
                };
            }

            // Create new invitation
            var invitation = new Invitation
            {
                Id = Guid.NewGuid(),
                TenantId = tenantId,
                Email = request.Email,
                Role = request.Role,
                Token = GenerateInvitationToken(),
                Status = "pending",
                ExpiresAt = DateTime.UtcNow.AddDays(7), // 7 days to accept
                CreatedAt = DateTime.UtcNow,
                CreatedBy = invitedBy
            };

            _context.Invitations.Add(invitation);
            await _context.SaveChangesAsync();

            // In a real implementation, you would send an email here
            // For now, we'll just log the invitation details
            _logger.LogInformation("Invitation created for {Email} to tenant {TenantId} with token {Token}",
                request.Email, tenantId, invitation.Token);

            // Audit log
            await LogAuditEventAsync("user.invited", invitedBy, tenantId, new
            {
                invited_email = request.Email,
                role = request.Role,
                invitation_id = invitation.Id
            });

            return new ApiResponse
            {
                Success = true,
                Message = "Invitation sent successfully"
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to invite user {Email} to tenant {TenantId}", request.Email, tenantId);
            throw;
        }
    }

    public async Task<LoginResponse> AcceptInvitationAsync(AcceptInvitationRequest request, HttpContext context)
    {
        var invitation = await _context.Invitations
            .Include(i => i.TenantId) // Include tenant for validation
            .FirstOrDefaultAsync(i => i.Token == request.Token && i.Status == "pending");

        if (invitation == null)
        {
            throw new ArgumentException("Invalid invitation token");
        }

        if (invitation.ExpiresAt < DateTime.UtcNow)
        {
            throw new ArgumentException("Invitation has expired");
        }

        User user;

        // Check if user already exists
        var existingUser = await _authService.GetUserByEmailAsync(invitation.Email);
        if (existingUser != null)
        {
            user = existingUser;
        }
        else
        {
            // Create new user account if password provided
            if (string.IsNullOrEmpty(request.Password))
            {
                throw new ArgumentException("Password is required for new users");
            }

            var registerRequest = new RegisterRequest
            {
                Email = invitation.Email,
                Password = request.Password,
                FirstName = request.FirstName ?? "",
                LastName = request.LastName ?? "",
                InvitationToken = request.Token
            };

            var loginResponse = await _authService.RegisterUserAsync(registerRequest, context);
            return loginResponse; // Registration handles invitation acceptance
        }

        // Add existing user to tenant
        var tenantUser = new TenantUser
        {
            Id = Guid.NewGuid(),
            TenantId = invitation.TenantId,
            UserId = user.Id,
            Role = invitation.Role,
            Status = "active",
            JoinedAt = DateTime.UtcNow,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        _context.TenantUsers.Add(tenantUser);

        // Update invitation status
        invitation.Status = "accepted";
        invitation.AcceptedAt = DateTime.UtcNow;
        invitation.AcceptedBy = user.Id;

        await _context.SaveChangesAsync();

        // Generate login response
        var tenant = await _context.Tenants.FirstOrDefaultAsync(t => t.Id == invitation.TenantId);

        // This is a simplified implementation - in practice, you'd want proper JWT generation
        throw new NotImplementedException("AcceptInvitationAsync needs JWT generation implementation");
    }

    public async Task<List<InvitationInfo>> GetPendingInvitationsAsync(Guid tenantId)
    {
        var query = from i in _context.Invitations
                   join u in _context.Users on i.CreatedBy equals u.Id
                   where i.TenantId == tenantId && i.Status == "pending" && i.ExpiresAt > DateTime.UtcNow
                   orderby i.CreatedAt descending
                   select new InvitationInfo
                   {
                       Id = i.Id,
                       Email = i.Email,
                       Role = i.Role,
                       Status = i.Status,
                       ExpiresAt = i.ExpiresAt,
                       CreatedAt = i.CreatedAt,
                       CreatedByName = u.DisplayName ?? $"{u.FirstName} {u.LastName}".Trim()
                   };

        return await query.ToListAsync();
    }

    public async Task<ApiResponse> CancelInvitationAsync(Guid invitationId, Guid cancelledBy)
    {
        var invitation = await _context.Invitations
            .FirstOrDefaultAsync(i => i.Id == invitationId && i.Status == "pending");

        if (invitation == null)
        {
            return new ApiResponse
            {
                Success = false,
                Message = "Invitation not found or already processed"
            };
        }

        invitation.Status = "cancelled";
        await _context.SaveChangesAsync();

        // Audit log
        await LogAuditEventAsync("invitation.cancelled", cancelledBy, invitation.TenantId, new
        {
            invitation_id = invitationId,
            invited_email = invitation.Email
        });

        return new ApiResponse
        {
            Success = true,
            Message = "Invitation cancelled successfully"
        };
    }

    private static string GenerateInvitationToken()
    {
        // Generate a secure random token
        var randomBytes = new byte[32];
        using var rng = RandomNumberGenerator.Create();
        rng.GetBytes(randomBytes);
        return Convert.ToBase64String(randomBytes).Replace("+", "-").Replace("/", "_").Replace("=", "");
    }

    private async Task LogAuditEventAsync(string action, Guid? userId, Guid? tenantId, object? metadata = null)
    {
        var auditLog = new FermentumApi.Models.AuditLog
        {
            AuditLogId = Guid.NewGuid(),
            Action = action,
            UserId = userId,
            TenantId = tenantId,
            Metadata = metadata != null ? System.Text.Json.JsonSerializer.Serialize(metadata) : null,
            Created = DateTime.UtcNow
        };

        _context.AuditLogs.Add(auditLog);
        await _context.SaveChangesAsync();
    }
}